/*
 * The MIT License
 *
 * Copyright (c) 2017 Fulcrum Genomics LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
package com.fulcrumgenomics.str.vcf

import com.fulcrumgenomics.FgBioDef.{FilePath, PathPrefix, PathToIntervals, PathToVcf, _}
import com.fulcrumgenomics.cmdline.ClpGroups
import com.fulcrumgenomics.commons.io.{Io, PathUtil}
import com.fulcrumgenomics.commons.util.{LazyLogging, NumericCounter, SimpleCounter}
import com.fulcrumgenomics.sopt.util._
import com.fulcrumgenomics.sopt.{arg, clp}
import com.fulcrumgenomics.str.cmdline.FgStrTool
import com.fulcrumgenomics.str.vcf.StrGenotypeConcordance._
import com.fulcrumgenomics.str.vcf.StrInterval.StrAllele
import com.fulcrumgenomics.util.Rscript
import enumeratum.values.{StringEnum, StringEnumEntry}
import htsjdk.variant.vcf.VCFFileReader
import scala.collection.immutable.StringOps

import scala.collection.mutable.ListBuffer
import scala.util.Failure

object StrGenotypeConcordance {
  sealed trait ConcordanceType extends StringEnumEntry {
    import com.fulcrumgenomics.str.vcf.StrGenotypeConcordance.ConcordanceType._
    def name: String = this.value
    def terminalName: String = {
      this match {
        case TruePositive | TrueNegative   => KBLD(KCYN(name))
        case FalsePositive | FalseNegative => KBLDRED(name)
        case NoCall                        => KBLD(KYEL(name))
      }
    }
  }

  case object ConcordanceType extends StringEnum[ConcordanceType] {
    override val values = findValues

    val maxNameLength: Int = this.values.map(_.name.length).max

    case object TruePositive extends ConcordanceType { val value: String = "True Positive" }
    case object TrueNegative extends ConcordanceType { val value: String = "True Negative" }
    case object FalsePositive extends ConcordanceType { val value: String = "False Positive" }
    case object FalseNegative extends ConcordanceType { val value: String = "False Negative" }
    case object NoCall extends ConcordanceType { val value: String = "No Call" }
  }
}


@clp(group=ClpGroups.VcfOrBcf, description=
  """
    |Calculates the concordance of STR genotypes.
    |
    |## Inputs
    |
    |The VCF from GenotypeFromGroupedBam should be given as input.
    |
    |An interval list specifying the set of regions over which to call STRs should be given. The name field should
    |contain a comma list of values as follows:
    |  1. the repeat unit length (ex. `3` for the tri-nucleotide repeat `TCATCATCATCA`).
    |  2. the number of repeat units (ex. `4` for the tri-nucleotide repeat `TCATCATCATCA`).
    |  3. the name of the STR (ex. D1S1656)
    |  4. the expected (known or truth) number of repeat units for allele #1
    |  5. the expected (known or truth) number of repeat units for allele #2
    |Columns 4-5 are required. See [the wiki](https://github.com/fulcrumgenomics/fgstr#input-requirements) for more
    |details.
    |
    |The `--max-distance` can be used to consider two similar STR calls the same, for example `--max-distance 0.5` will
    |consider the calls `17.0` and `17.5` to be the same.
    |
    |## Outputs
    |
    |  * `<outout>.pdf` - the same plot as generated by `GenotypeFromGroupedBam`.
    |  * `<output>.stutter.tab> - attempts to estimate the frequency of stutter events.  A stutter occurs when we have
    |    one or more bases missing or present relative to the ground truth.  The stutter distance is the minimum # of
    |    bases different between the given call and any ground truth allele.
    |    1. "stutter"         - the # of repeat units different from the most similar (in length) truth allele.
    |    2. "all_sites"       - the counts across all STR sites.
    |    3. "confident_sites" - the counts across all confident sites (homozygous sites or sites with at least a 4 unit
    |                           repeat difference between the two ground truth alleles)
    |  * `<output>.concordance.tab> - the count per concordance state; computed on a per-allele basis.
    |  * logging information: the tool will also log the following information: per STR:
    |    1. the STR name, # of repeats for the reference, ground truth (both alleles), genotype call (both alleles), and
    |       concordance states (one per allele).
    |    2. a line per observed allele in the raw per-molecule calls, with called # of repeats, the stutter length, the
    |       raw coverage, and true or false based on if the site is "confident site" (see above).
    |    3. summary tables for the stutter and concordance counts.
    |    NB: terminal escape codes are used for logging to highlight the concordance states.
  """)
class StrGenotypeConcordance
(
  @arg(flag='i', doc="Input VCF of variant calls from GenotypeFromGroupedBam.") val input: PathToVcf,
  @arg(flag='l', doc="Interval list with the STR regions and known calls.") val intervals: PathToIntervals,
  @arg(flag='o', doc="Prefix for all output files.") val output: PathPrefix,
  @arg(flag='m', doc="Maximum repeat distance to consider two calls the same") val maxDistance: Double = 0,
  @arg(          doc="Use the STR_GT field to get the STR genotype") val useStrGt: Boolean = true,
  @arg(          doc="Calculate stutter counts only at concordant sites") val requireConcordanceForStutter: Boolean = true,
  private val skipPlots: Boolean = false // for not plotting in tests
) extends FgStrTool with LazyLogging {
  import com.fulcrumgenomics.str.vcf.StrGenotypeConcordance.ConcordanceType._

  private val ScriptPath = "com/fulcrumgenomics/str/vcf/StrGenotypeDuplexMolecules.R"

  Io.assertReadable(input)
  Io.assertReadable(intervals)
  Io.assertCanWriteFile(output)

  // find the one closes to zero
  private def minAbs(x: Double*): Double = {
    val min = x.map(Math.abs).min
    x.find { y => Math.abs(y) == min }.get
  }

  private def count(str: StrInterval, call: Double, known: Double): ConcordanceType = {
    if (Math.abs(known - call) <= maxDistance) {
      if (Math.abs(str.refLength - call) <= maxDistance) TrueNegative else TruePositive
    }
    else {
      if (Math.abs(str.refLength - call) <= maxDistance) FalseNegative else FalsePositive
    }
  }

  private def logConcordance(str: StrInterval, known1: Double, known2: Double, call1: Double, call2: Double, concordances: Seq[ConcordanceType]): Unit = {
    logger.info(f"[${KBLD(KWHT(str.name))}] Ref [${str.refLength.toDouble}%.2f] Truth [$known1%.2f,$known2%.2f] Call [$call1%.2f,$call2%.2f] Concordance [${concordances.map(_.terminalName).mkString(",")}]")
  }

  override def execute(): Unit = {
    def f(ext: String): FilePath = PathUtil.pathTo(output + ext)

    val infoWriter   = Io.toWriter(f(".info.txt"))
    val vcfIn        = new VCFFileReader(input.toFile, false)
    val strIntervals = StrInterval.loadIntervals(this.intervals).toSeq

    require(vcfIn.getFileHeader.getNGenotypeSamples == 1, s"Expected a single sample, found '${vcfIn.getFileHeader.getNGenotypeSamples}'")

    val minStutterDistance      = 4
    val stutterCounter          = new NumericCounter[Int]()
    val stutterConfidentCounter = new NumericCounter[Int]()

    val alleleConcordanceCounter = {
      val counter = new SimpleCounter[ConcordanceType]()
      ConcordanceType.values.foreach { concordanceType => counter.count(concordanceType, 0) }
      counter
    }

    strIntervals.filter { str => str.known1.isDefined && str.known2.isDefined}.foreach { str =>
      var numOverlapping = 0

      val (known1, known2) = {
        val k1 = str.known1.get
        val k2 = str.known2.get
        if (k1 <= k2) (k1, k2) else (k2, k1)
      }
      val knowns = Seq(known1, known2)

      vcfIn.query(str.chrom, str.start, str.end)
        .filter(_.getNoCallCount == 0)
        .foreach { ctx =>
          // Get all calls seen, not just the one genotyped
          val counts = {
            val refCount   = ctx.getAttributeAsInt("REFAC", 0)
            val altCounts = ctx.getAttributeAsIntList("AC", 0).map(_.toInt).toSeq
            refCount +: altCounts
          }
          val allCalls = StrAllele.toCalls(str, ctx, counts) // TODO: use this for stutter model

          // Get the genotype calls
          val (call1: Double, call2: Double) = if (useStrGt) {
            val strGenotype = ctx.getGenotype(0).getAnyAttribute("STR_GT").toString
            strGenotype.split(',').map(_.toDouble).toSeq match {
              case Seq(a, b) => if (a <= b) (a, b) else (b, a)
              case _         => throw new IllegalArgumentException(s"Could not parse STR_GT FORMAT field: '$strGenotype'")
            }
          }
          else {
            val a = allCalls.head.repeatLength / str.unitLength.toDouble
            if (ctx.getGenotype(0).isHom) {
              (a, a)
            }
            else {
              val b = allCalls.drop(1).head.repeatLength / str.unitLength.toDouble
              if (a <= b) (a, b) else (b, a)
            }
          }
          require(call1 <= call2)

          // Update the concordance counts
          val calls = Seq(call1, call2)
          val concordances = calls.zip(knowns).map { case (call, known) => count(str, call, known) }
          concordances.foreach { c => alleleConcordanceCounter.count(c) }
          logConcordance(str, known1, known2, call1, call2, concordances)

          // Update the stutter counts
          val confidentSite = Math.abs(known1 - known2) >= minStutterDistance || known1 == known2
          val concordant = concordances.forall { c => c == TruePositive || c == TrueNegative }
          allCalls.foreach { call =>
            val callLength = call.repeatLength / str.unitLength.toDouble
            val stutter = {
              val abs = minAbs(callLength - known1, callLength - known2)
              if (abs < 0) Math.ceil(abs) else Math.floor(abs)
            }.toInt
            if (!requireConcordanceForStutter || concordant) {
              stutterCounter.count(stutter, call.count)
              if (confidentSite) stutterConfidentCounter.count(stutter, call.count)
            }
          }
          logger.info("")

          infoWriter.write(str.toLongString(allCalls) + "\n")

          numOverlapping += 1
        }
      if (numOverlapping == 0) {
        alleleConcordanceCounter.count(NoCall, 2)
        logConcordance(str, known1, known2, -1, -1, Seq(NoCall, NoCall))
        logger.info("")
      }
      else {
        require(numOverlapping == 1, s"Found $numOverlapping variants for str '${str.name}'")
      }
    }

    infoWriter.close()
    vcfIn.safelyClose()

    // Stutter
    {
      val lines = ListBuffer[String]()
      lines += "stutter\tall_sites\tconfident_sites"
      (stutterCounter.map(_._1) ++ stutterConfidentCounter.map(_._1)).toSeq.distinct.sorted.foreach { stutter =>
        lines += f"$stutter%2d\t${stutterCounter.countOf(stutter)}%6d\t${stutterConfidentCounter.countOf(stutter)}%6d"
      }
      val out = f(".stutter.tab")
      Io.writeLines(out, lines)

      logger.info(KBLD(KGRN("Stutter:")))
      lines.foreach { line => logger.info("    " + line.replace('\t', ' ')) }
      logger.info("    " + out)
      logger.info("")
    }

    // Concordance
    {
      val lines = ListBuffer[String]()
      lines += "type\tcount"
      ConcordanceType.values.foreach { concordance =>
        lines += f"${concordance.name.padTo(ConcordanceType.maxNameLength, " ").mkString("")}\t${alleleConcordanceCounter.countOf(concordance)}%6d"
      }
      val out = f(".concordance.tab")
      Io.writeLines(out, lines)

      logger.info(KBLD(KGRN("Per-Allele Concordance:")))
      lines.foreach { line => logger.info("    " + line.replace('\t', ' ')) }
      logger.info("    " + out)
    }

    if (!skipPlots && strIntervals.nonEmpty) {
      Rscript.execIfAvailable(ScriptPath, f(".info.txt").toString, f(".pdf").toString) match {
        case Failure(e) => logger.warning(s"Generation of PDF plots failed: ${e.getMessage}")
        case _ => Unit
      }
    }
    else {
      logger.warning("No variants outputted, skipping plots")
    }
  }
}