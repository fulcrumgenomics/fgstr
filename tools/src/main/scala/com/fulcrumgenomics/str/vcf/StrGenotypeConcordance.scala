/*
 * The MIT License
 *
 * Copyright (c) 2017 Fulcrum Genomics LLC
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */
package com.fulcrumgenomics.str.vcf

import com.fulcrumgenomics.FgBioDef.{FilePath, PathPrefix, PathToIntervals, PathToVcf, _}
import com.fulcrumgenomics.cmdline.ClpGroups
import com.fulcrumgenomics.commons.io.{Io, PathUtil}
import com.fulcrumgenomics.commons.util.{LazyLogging, SimpleCounter}
import com.fulcrumgenomics.sopt.util._
import com.fulcrumgenomics.sopt.{arg, clp}
import com.fulcrumgenomics.str.cmdline.FgStrTool
import com.fulcrumgenomics.str.vcf.StrGenotypeConcordance._
import com.fulcrumgenomics.str.vcf.StrInterval.StrAllele
import com.fulcrumgenomics.util.Rscript
import enumeratum.values.{StringEnum, StringEnumEntry}
import htsjdk.variant.vcf.VCFFileReader

import scala.collection.mutable.ListBuffer
import scala.util.Failure

object StrGenotypeConcordance {
  sealed trait ConcordanceType extends StringEnumEntry {
    import com.fulcrumgenomics.str.vcf.StrGenotypeConcordance.ConcordanceType._
    def name: String = this.value
    def terminalName: String = {
      this match {
        case TruePositive | TrueNegative   => KBLD(KCYN(name))
        case FalsePositive | FalseNegative => KBLDRED(name)
        case NoCall                        => KBLD(KYEL(name))
      }
    }
  }

  case object ConcordanceType extends StringEnum[ConcordanceType] {
    override val values = findValues

    val maxNameLength: Int = this.values.map(_.name.length).max

    case object TruePositive extends ConcordanceType { val value: String = "True Positive" }
    case object TrueNegative extends ConcordanceType { val value: String = "True Negative" }
    case object FalsePositive extends ConcordanceType { val value: String = "False Positive" }
    case object FalseNegative extends ConcordanceType { val value: String = "False Negative" }
    case object NoCall extends ConcordanceType { val value: String = "No Call" }
  }
}


@clp(group=ClpGroups.VcfOrBcf, description=
  """
    |Calculates the concordance of STR genotypes.
    |
    |## Inputs
    |
    |The VCF from `GenotypeFromGroupedBam` should be given as input.
    |
    |An interval list specifying the set of regions over which to call STRs should be given. The name field should
    |contain a comma list of values as follows:
    |  1. the repeat unit length (ex. `3` for the tri-nucleotide repeat `TCATCATCATCA`).
    |  2. the number of repeat units (ex. `4` for the tri-nucleotide repeat `TCATCATCATCA`).
    |  3. the name of the STR (ex. D1S1656)
    |Additional columns can be given for one or more expected truth alleles.  For example, a known haploid
    |call should have one extra column, a known diploid call should have two extra columns, and so on.
    |
    |The `--max-distance` can be used to consider two similar STR calls the same, for example `--max-distance 0.5` will
    |consider the calls `17.0` and `17.5` to be the same.
    |
    |## Outputs
    |
    |  * `<outout>.pdf` - the same plot as generated by `GenotypeFromGroupedBam`.
    |  * `<output>.concordance.tab> - the count per concordance state; computed on a per-allele basis.
    |  * logging information: the tool will also log the following information: per STR:
    |    1. the STR name, # of repeats for the reference, ground truth (both alleles), genotype call (both alleles), and
    |       concordance states (one per allele).
    |    2. a line per observed allele in the raw per-molecule calls, with called # of repeats, the stutter length, the
    |       raw coverage, and true or false based on if the site is "confident site" (see above).
    |    3. summary tables for the stutter and concordance counts.
    |    NB: terminal escape codes are used for logging to highlight the concordance states.
  """)
class StrGenotypeConcordance
(
  @arg(flag='i', doc="Input VCF of variant calls from `GenotypeFromGroupedBam`.") val input: PathToVcf,
  @arg(flag='l', doc="Interval list with the STR regions and known calls.") val intervals: PathToIntervals,
  @arg(flag='o', doc="Prefix for all output files.") val output: PathPrefix,
  @arg(flag='m', doc="Maximum repeat distance to consider two calls the same") val maxDistance: Double = 0,
  private val skipPlots: Boolean = false // for not plotting in tests
) extends FgStrTool with LazyLogging {
  import com.fulcrumgenomics.str.vcf.StrGenotypeConcordance.ConcordanceType._

  private val ScriptPath = "com/fulcrumgenomics/str/vcf/StrGenotypeDuplexMolecules.R"

  Io.assertReadable(input)
  Io.assertReadable(intervals)
  Io.assertCanWriteFile(output)

  // find the one closes to zero
  private def minAbs(x: Double*): Double = {
    val min = x.map(Math.abs).min
    x.find { y => Math.abs(y) == min }.get
  }

  private def count(str: StrInterval, call: Double, known: Double): ConcordanceType = {
    if (Math.abs(known - call) <= maxDistance) {
      if (Math.abs(str.refLength - call) <= maxDistance) TrueNegative else TruePositive
    }
    else {
      if (Math.abs(str.refLength - call) <= maxDistance) FalseNegative else FalsePositive
    }
  }

  private def logConcordance(str: StrInterval, truth: Seq[Double], call: Seq[Double], concordances: Seq[ConcordanceType]): Unit = {
    val truthStr = truth.map(t => f"$t%.2f").mkString(",")
    val callStr  = call.map(c => f"$c%.2f").mkString(",")
    logger.info(f"[${KBLD(KWHT(str.name))}] Ref [${str.refLength.toDouble}%.2f] Truth [$truthStr] Call [$callStr] Concordance [${concordances.map(_.terminalName).mkString(",")}]")
  }

  override def execute(): Unit = {
    def f(ext: String): FilePath = PathUtil.pathTo(output + ext)

    val infoWriter   = Io.toWriter(f(".info.txt"))
    val vcfIn        = new VCFFileReader(input.toFile, false)
    val strIntervals = StrInterval.loadIntervals(this.intervals).toSeq

    require(vcfIn.getFileHeader.getNGenotypeSamples == 1, s"Expected a single sample, found '${vcfIn.getFileHeader.getNGenotypeSamples}'")

    val alleleConcordanceCounter = {
      val counter = new SimpleCounter[ConcordanceType]()
      ConcordanceType.values.foreach { concordanceType => counter.count(concordanceType, 0) }
      counter
    }

    strIntervals.filter { str => str.truthCalls.nonEmpty}.foreach { str =>
      var numOverlapping = 0
      val knowns = str.truthCalls.map(_.toDouble).sorted // from low to high

      vcfIn.query(str.chrom, str.start, str.end)
        .filter(_.getNoCallCount == 0)
        .foreach { ctx =>
          // Get all calls seen, not just the one genotyped
          val counts = {
            val refCount  = ctx.getAttributeAsInt("REFAC", 0)
            val altCounts = ctx.getAttributeAsIntList("AC", 0).map(_.toInt).toSeq
            refCount +: altCounts
          }
          val allCalls = StrAllele.toCalls(str, ctx, counts)

          // Get the genotype calls
          val calls = ctx.getGenotype(0)
            .getAttributeAsString("STR_GT", "")
            .split(',')
            .map(_.toDouble)
            .toSeq.sorted // from low to high

          // Update the concordance counts
          val concordances = {
            // TODO: order the concordances in the same order as calls
            // Match the calls with the knowns.  Iteratively find the pair of call and known that are the closest match.
            val knownsLeft       = ListBuffer[Double](knowns:_*)
            val callsLeft        = ListBuffer[Double](calls:_*)
            val callConcordances = ListBuffer[ConcordanceType]()
            while (callsLeft.nonEmpty && knownsLeft.nonEmpty) {
              // find the call and known pair that have the minimum distance
              val (call, known, _) = callsLeft.map { _call =>
                val minKnown = knownsLeft.minBy { _known => Math.abs(_known - _call) }
                (_call, minKnown, Math.abs(minKnown - _call))
              }.minBy(_._3)
              callConcordances += count(str, call, known)
              callsLeft -= call
              knownsLeft -= call
            }
            // In case we have a mismatching # of alleles.
            val extraConcordances = if (calls.length < knowns.length) {
              Seq.range(0, knowns.length - calls.length).map { _ => FalseNegative }
            }
            else if (calls.length > knowns.length) {
              Seq.range(0, calls.length - knowns.length).map { _ => FalsePositive }
            }
            else {
              Seq.empty
            }
            callConcordances ++ extraConcordances
          }

          concordances.foreach { c => alleleConcordanceCounter.count(c) }
          logConcordance(str, knowns, calls, concordances)

          // Log some stutter information.
          allCalls.foreach { call =>
            val stutter = {
              val abs = minAbs(knowns.map(k => call.repeatLength - k):_*)
              if (abs < 0) Math.ceil(abs) else Math.floor(abs)
            }.toInt
            logger.info(f"\tstutter [$stutter] call [${call.repeatLength}] depth [${call.count}]")
          }
          logger.info("")

          infoWriter.write(str.toLongString(allCalls) + "\n")

          numOverlapping += 1
        }
      if (numOverlapping == 0) {
        alleleConcordanceCounter.count(NoCall, 2)
        logConcordance(str, knowns, knowns.map(_ => -1.0), Seq(NoCall, NoCall))
        logger.info("")
      }
      else {
        require(numOverlapping == 1, s"Found $numOverlapping variants for str '${str.name}'")
      }
    }

    infoWriter.close()
    vcfIn.safelyClose()

    // Concordance
    {
      val lines = ListBuffer[String]()
      lines += "type\tcount"
      ConcordanceType.values.foreach { concordance =>
        lines += f"${concordance.name.padTo(ConcordanceType.maxNameLength, " ").mkString("")}\t${alleleConcordanceCounter.countOf(concordance)}%6d"
      }
      val out = f(".concordance.tab")
      Io.writeLines(out, lines)

      logger.info(KBLD(KGRN("Per-Allele Concordance:")))
      lines.foreach { line => logger.info("    " + line.replace('\t', ' ')) }
      logger.info("    " + out)
    }

    if (!skipPlots && strIntervals.nonEmpty) {
      Rscript.execIfAvailable(ScriptPath, f(".info.txt").toString, f(".pdf").toString) match {
        case Failure(e) => logger.warning(s"Generation of PDF plots failed: ${e.getMessage}")
        case _ => Unit
      }
    }
    else {
      logger.warning("No variants outputted, skipping plots")
    }
  }
}